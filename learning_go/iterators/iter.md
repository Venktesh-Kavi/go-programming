## Iterators in Go

Why do we need iterators?

* We typically range over slices, maps, channels or strings.
* But this requires having all of the slice readily available to iterate over them.
* In cases where slice is being generated by some other method, one needs to wait for the all of the slice to be
  available.
* This can be an unnecessary usage of CPU and memory if we are not all the slice items.
* Assume that we want to iterate over only few elements and see if it matches a condition or criteria, having or
  allocation a whole slice is unnecessary.
* So what if there is something like a slice, but it produces only one element at a time. (Lets call this an iterator)
* For loop over such an iterator will execute once for each result that the iterator produces.

``` go 
func iterateItems(yield func(Item) bool) {
    items := []Items{1, 2, 3} // dummy data
    
    for _, item := range items {
        if !yield(item) {
            return
        }
    }
}

iterateItems(func(item Item) bool {
    fmt.Println(item)
    return false
})

// In the above example one cannot directly use iterateItems function in range clause and execute it.
// Go 1.23 has introduced iterators which has a special function type iter.Seq[V any] and iter.Seq[T any, V any] to use in range

func iterItems(items []Item) iter.Seq[Item] {
  return func(yield func(Item) bool) {
        for _, item := range items {
          if !yield(item) {
            break
          }
        }
  }
}
```

## Dealing with errors in iterators

* Iterators produce data, but what if there is an error while producing the data.
* One option is return an empty data point, but the consumer would be unaware of the error.
* We can use the eg.., `iter.Seq2[string, error]` function type.

## Cleaning Up

* Here are passing the source data as items to the iterator and asking it to produce.
* Ideally there can be source embedded in the iterator and the iterator could produce data.
* In case of embedded data sources like DB, we might want the yield function to return a false, so that we can indicate
  the iterator that its job is done and ask it to clean resources if any.

## Composing Iterators

### Function can take iterator

``` go
func PrintPrimes() {
  for p := range Primes(Integers()) {
    fmt.Println(p)
  }
}

func Primes(seq iter.Seq[int]) iter.Seq[int] {
  return func(yield func(int) bool) {
    for s := range seq {
      if isPrime(s) {
        if !yield(s) {
          break
        }
      }
    }
  }
}

func Integers() iter.Seq[int] {
  return func(yield func(int) bool) {
    for i := range math.MaxInt {
      if !yield(i) {
        break
      }
    }
  }
}
```

#

Reference

- https://bitfieldconsulting.com/posts/iterators